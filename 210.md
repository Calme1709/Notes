# My notes for CS210 (University Of Auckland)

# ASCII
---
##### Values
0-9: x30-x39

A-Z: x41-x5A

a-z: x61-x7A
##### Conversions
Uppercase -> Lowercase: Add x20

Lowercase -> Uppercase: Subtract x20

# Von Neumann model
---
#### Components
##### Memory
Contains instructions and data for the program.
##### Processing Unit
Performs arithmetic and logical operations
##### Control Unit
Interprets instructions
##### IO
Interacts with the outside world

# Instruction Processing
---
There are 6 steps to the processing of an instruction.
##### 1. Fetch.
- Load the contents of the PC into MAR

- Read the contents of MDR into IR

- Increment the PC.

##### 2. Decode
- Identify the opcode, in LC3 this is the first four bits of the instruction.

- From the opcode, identify the operands for the instruction.

##### 3. Evaluate Address
- Compute any required memory addresses.

##### 4. Fetch Operands
- Obtain the operands, either from memory or from registers.

##### 5. Execute
- Execute the operation specified by the opcode with the specified operands.

- Do nothing for operations which require no execution (LD, ST, etc)

##### 6. Store
- Write the result of the operation to the destination. (Register or memory location)

# LC3
---
### Data Types
##### Word
A word is the size of a piece of data in an instruction set. In LC3 this is 2 Bytes (16 bits).
A instruction is one word long, and each memory address points to a word.
##### PCOffset
A signed integer(usually 9 bits) which specifies an offset from the PC to a desired memory location.

### Registers
#### General Purpose Registers
There are 8 general purpose registers (R0 - R7), and they can generally be used for anything in the program.

#### Special Registers
##### PC
The program counter, this contains the address of the next instruction to be executed.

##### IR
The instruction register, this contains the currently executed instruction.

##### MAR
The memory address register, used to specify the memory to read from or write to.

##### MDR
The memory data register, contains the data that has been read from or is to be written to memory.

### Instructions
#### BR(nzp)
Branch to a different location depending on the values in the control register
###### Assembly:
BR(nzp) OFFSET
###### Operations:
\*N,Z,P are the last three bits of PSR
if((n&&N) || (z&&Z) || (p&&P)) PC = PC + Offset
###### Machine Code:
I[15:12]: 0000

I[11]: n, whether to branch on negative (1 if so, 0 if not)

I[10]: z, whether to branch on zero (1 if so, 0 if not)

I[9]: p, whether to branch on positive (1 if so, 0 if not)

I[8:0]: PCOffset to the instruction which should be executed next if the program branches.

#### ADD
Add the value of two registers together and store into another register, there are two modes (Immediate and register).
###### Assembly:
ADD DR, SR1, (SR2 | Constant)
###### Operations:
DR = SR1 + (SR2 | Constant)
###### Machine Code:
I[15:12]: 0001

I[11:9]: DR (0-7)

I[8:6]: SR1, (0-7)
###### Immediate Mode
Add a constant number to SR1.
I[5]: 1

I[4:0]: The integer to add.
###### Register Mode
Add the value of another register (SR2) to SR1
I[5]: 0

I[4:3]: 00

I[2:0]: SR2 (0-7).

#### LD
Load a word from memory into a register.
###### Assembly:
LD DR, OFFSET
###### Operations:
DR = mem[PC + OFFSET]
###### Machine Code:
I[15:12]: 0010

I[11:9]: Destination register

I[8:0]: PCOffset to the location to where to load from.

#### ST
Store a word from a register into memory.
###### Assembly:
ST SR, OFFSET
###### Operations:
mem[PC + OFFSET] = SR
###### Machine Code:
I[15:12] 0011

I[11:9]: SR

I[8:0]: PCOffset to the location to store at.

#### JSR
Jump to a subroutine specified by the offset, sets R6 to the current PC before jumping.
###### Assembly:
JSR OFFSET
###### Operations:
R7 = PC

PC = PC + OFFSET
###### Machine Code:
I[15:12]: 0100

I[11]: 1

I[10:0]: PCOffset to the entry to the subroutine.

#### JSRR
Jump to a subroutine specified by a registers value.
###### Assembly:
JSRR SR
###### Operations:
R7 = PC

PC = SR
###### Machine Code:
I[15:12]: 0100

I[11:9]: 000

I[8:6]: SR

I[5:0]: 000000

#### AND
AND two values together and store the value in a register. There are two modes (Register mode and Immediate mode).
###### Assembly:
AND DR, SR1, (SR2 | Constant)
###### Operations:
DR = SR1 & (SR2 | Constant)
###### Machine Code:
I[15:12]: 0101

I[11:9]: DR

I[8:6]: SR1 - Operand One

##### Immediate mode
AND the value of SR1 with a constant value
I[5]: 1

I:[4:0]: A 5 bit value to AND with SR1 - Operand Two

##### Register mode
I[5:3]: 000

I[2:0]: SR2 - Operand Two

#### LDR
Load a value into a register from an offset relative to a base.
###### Assembly:
LDR DR, SR1, OFFSET
###### Operations:
DR = mem[SR1 + OFFSET]
###### Machine Code:
I[15:12]: 0110

I[11:9]: DR

I[8:6]: SR1 - Base

I[5:0]: Offset (6 bit singed int)

#### STR
Store a value into memory from an offset relative to a base
###### Assembly:
LDR SR1, SR2, OFFSET
###### Operations:
mem[SR2 + OFFSET] = SR1
###### Machine Code:
I[15:12]: 0111

I[11:9]: SR1 - Data

I[8:6]: SR2 - Base

I[5:0]: Offset (6 bit singed int)

#### NOT
NOT a value and store it in a register
###### Assembly:
NOT DR, SR1
###### Operations:
DR = !SR1
###### Machine Code:
I[15:12]: 1001

I[11:9]: DR

I[8:6]: SR1

I[5:0]: 111111

#### LDI
Load a value from memory into a register indirectly (Load the value that is referenced by the value that is referenced by the PCOffset)
###### Assembly:
LDI DR, OFFSET
###### Operations:
DR = mem[mem[PC + OFFSET]
###### Machine Code:
I[15:12]: 1010

I[11:9]: DR

I[8:0]: PCOffset - The offset to the memory location which stores where to load into DR from.

#### STI
Store a value into memory from a register indirectly (Store the value to the memory location referenced by the value that is referenced by the PCOffset)
###### Assembly:
LDI SR, OFFSET
###### Operations:
mem[mem[PC + OFFSET] = SR
###### Machine Code:
I[15:12]: 1011

I[11:9]: SR

I[8:0]: PCOffset - The offset to the memory location which stores where to store the value of SR

#### JMP
Set PC to the value stored in SR1. RET is just shorthand for JMP R7.
###### Assembly:
JMP SR1
###### Operations:
PC = SR1
###### Machine Code:
I[15:12]: 1100

I[11:9]: 000

I[8:6]: SR1

I[5:0]: 000000

#### LEA
Load the effective address of an offset
###### Assembly:
LEA DR, OFFSET
###### Operations:
DR = PC + OFFSET
###### Machine Code:
I[15:12]: 1110

I[11:9]: DR

I[8:0]: PCOffset

#### TRAP
Execute a Trap routine according to the memory location referenced by the trapvector.
###### Assembly:
TRAP trapcode
###### Operations:
R7 = PC

PC = mem[trapcode]
###### Machine Code:
I[15:12]: 1111

I[11:8]: 0000

I[7:0]: trapcode

There are up to 256 trap routines, some common ones are:
##### x20: GETC:
Read a character from the input
###### Inputs:
None
###### Outputs:
R0 - The character read from the input 
##### x21: OUT:
Write a character to the output
###### Inputs:
R0 - The character to write
###### Outputs:
None
##### x22: PUTS:
Write a null terminated string which starts at the memory location in R0 to the output
###### Inputs:
R0-  The location of the string.
###### Outputs:
None
##### x23: IN:
Read and echo a character from the keyboard.
###### Inputs:
None
###### Outputs:
R0 - The character read from the input 
##### x25: HALT:
Halt the program and output a halting message.
###### Inputs:
None
###### Outputs:
None
### Data
#### .STRINGZ
A null terminated string, the length of this is equal to the number of characters plus one for the null terminator.
##### Example:
.STRINGZ "Hello, World" - Takes up 11 words of memory.
#### .BLKW
Allocate a certain number of words to be empty at the start of the program.
##### Example:
.FILL x4 - Allocates the next four words.
#### .FILL
Set a word to a constant value.
##### Example:
.FILL x0002 - Sets the value of this memory location to x2
